# Computes the battery degradation following ESPA model formulations,# which is based on Rosewater, et al 2019import numpy as npimport osimport pandas as pd# import datetimeimport jsonclass Degradation:    def __init__(self, soc_array, temp_array, times_array, t_start, storage_df):        self.socs = 1.0*soc_array        self.temps = 1.0*temp_array        self._times = times_array        self.t_start = (t_start-self._times[0]).total_seconds() / 3600 # Hours        self.rids = ['R00229'] # Arbitrary resource identifier        self.K_time = storage_df.loc[:,'deg_time'].values        self.K_therm = storage_df.loc[:,'deg_therm'].values        self.K_soc = storage_df.loc[:,'deg_soc'].values        self.C_EoL = storage_df.loc[:,'cost_EoL'].values        self.A0 = storage_df.loc[:,'deg_DoD0'].values        self.A1 = storage_df.loc[:,'deg_DoD1'].values        self.A2 = storage_df.loc[:,'deg_DoD2'].values        self.A3 = storage_df.loc[:,'deg_DoD3'].values        self.A4 = storage_df.loc[:,'deg_DoD4'].values        self.A_Tref = storage_df.loc[:,'temp_ref'].values        self.soc_capacity = np.array((storage_df.loc[:,'soc_capacity'].values))        self.socs /= self.soc_capacity[0]        self.A_socref = np.array((storage_df.loc[:,'socref'].values))/self.soc_capacity        self.num_stack = storage_df.loc[:,'cell_count'].values    def compute_degradation_cost(self):        '''        Uses soc/temp/time arrays and battery attributes to compute degradation cost        '''        # Make times an array of differences then convert to minutes        self._times -= self._times[0]        self.times = np.zeros(len(self._times)) # Make a new array of floats instead of datetimes        self.sidx = 0        for i in range(len(self.times)):            # Time in Rosewater paper is in units of hours            time_hrs = self._times[i].total_seconds() / 3600            self.times[i] = time_hrs            if self.times[i] <= self.t_start:                self.sidx += 1        degradation_costs = {} # np.zeros(len(self.rids))              for k in range(len(self.rids)):                        # Compute all of the parameters, then find the degradation cost            self.calculate_parameters(k, self.sidx)                        # Compute again to get the starting SoH value (self.f_start)            self.dSoH_dt = (np.exp(-self.f_start) - np.exp(-self.f))/(self.t_start-self.times[-1])            # Eqn 120 (give or take) in model_formulations_v1-1            degradation_costs[self.rids[k]] = self.C_EoL[k] * self.dSoH_dt * (self.times[-1]-self.t_start)        if len(degradation_costs) == 1:            key1 = list(degradation_costs.keys())[0]            degradation_costs = degradation_costs[key1]        return degradation_costs        def calculate_parameters(self, idx, sidx):        # Find the average soc and temperature        self.soc = np.sum(self.socs[idx,:])/len(self.socs[idx,:])        self.temp = np.sum(self.temps[idx,:])/len(self.temps[idx,:])                self.F_t = self.K_time[idx]*self.times[-1] / 1.5 # Total time so far...        self.F_T = np.exp(self.K_therm[idx]*(self.temp-self.A_Tref[idx])*self.A_Tref[idx]/self.temp)        self.F_S = np.exp(self.K_soc[idx]*(self.soc-self.A_socref[idx]))        self.D_vec = self.rainflow(idx, len(self.times))        if type(self.D_vec) is int:            ld = 1        else:            ld = len(self.D_vec)        self.delta = np.sum(self.D_vec)/ld        self.F_D = self.A0[idx] + self.A1[idx]*self.delta + self.A2[idx]*self.delta**2 + \            self.A3[idx]*self.delta**3 + self.A4[idx]*self.delta**4        self.F_D /= 1e4        self.f = self.F_t*self.F_S*self.F_T + np.sum(self.D_vec)*self.F_D*self.F_S*self.F_T        # Re-do everything to find f at the start of this interval        self.soc_st = np.sum(self.socs[idx,:sidx])/len(self.socs[idx,:sidx])        self.temp_st = np.sum(self.temps[idx,:sidx])/len(self.temps[idx,:sidx])        self.F_t_st = self.K_time[idx]*self.t_start / 1.5 # Total time up to start point        self.F_T_st = np.exp(self.K_therm[idx]*(self.temp_st-self.A_Tref[idx])*self.A_Tref[idx]/self.temp_st)        self.F_S_st = np.exp(self.K_soc[idx]*(self.soc_st-self.A_socref[idx]))        self.D_vec_st = self.rainflow(idx, sidx)        if type(self.D_vec_st) is int:            ld = 1        else:            ld = len(self.D_vec_st)        self.deltas = np.sum(self.D_vec_st)/ld        self.F_D_st = self.A0[idx] + self.A1[idx]*self.deltas + self.A2[idx]*self.deltas**2 + \            self.A3[idx]*self.deltas**3 + self.A4[idx]*self.deltas**4        self.F_D_st /= 1e4        self.f_start = self.F_t_st*self.F_S_st*self.F_T_st + \            np.sum(self.D_vec_st)*self.F_D_st*self.F_S_st*self.F_T_st            def rainflow(self, idx, sidx):        # 1: soc profile is self.socs        # 2: remove all non-peak, non-trough values (keeping 1st, last elements)        delete_inds = []        on_plateau = False        incoming_dlt = 0        tol = 0.0001        for i in range(len(self.socs[idx,:sidx])):            if i == 0 or i == len(self.socs[idx,:sidx])-1:                continue            dlt1 = (self.socs[idx,i] - self.socs[idx,i-1])            dlt2 = (self.socs[idx,i+1] - self.socs[idx,i])            # Make sure floating point errors don't count as sign changes            if abs(dlt1) < tol:                dlt1 = 0            if abs(dlt2) < tol:                dlt2 = 0            is_max_min = (dlt1*dlt2)<0            # Logic to handle soc plateau peaks/troughs            if on_plateau and (incoming_dlt*dlt2) < 0:                is_max_min = True            if dlt2 == 0:                if not on_plateau:                    incoming_dlt = dlt1                on_plateau = True            else:                on_plateau = False            if not is_max_min:                delete_inds += [i]        _socs = np.delete(self.socs[idx,:sidx], delete_inds)        # Check that it didn't end on a plateau. If it did, delete the extra        if len(_socs) < 2:            return 0        if abs(_socs[-1] - _socs[-2]) < tol:            _socs = np.delete(_socs, -1)        # 3: Reorder so highest peak occurs first and append peak to be the last element        max_idx = np.argmax(_socs)        max_val = _socs[max_idx]        mask = np.arange(len(_socs),dtype=int)+max_idx        mask[mask>=len(mask)] -= len(mask)        _socs = _socs[mask]        _socs = np.append(_socs, max_val)        _socs = list(_socs)        # 4: Create empty vectors R and D (using lists, convert to array at end)        R, D = [], []        add_pt = False        while len(_socs) > 0:            if len(_socs)+len(R) < 3:                break            # 5, 6: remove first element from s and insert it at the beginning of R until len(R)==3            while len(R) < 3:                R = [_socs[0]] + R                _socs.remove(_socs[0])            # Draw the next point as needed            if add_pt:                R = [_socs[0]] + R                _socs.remove(_socs[0])            # 7: Set X and Y as the magnitude differences            X, Y = abs(R[0]-R[1]), abs(R[1]-R[2])            # 8: Check if X >= Y. If so, add Y to vector D and remove 2nd, 3rd elements from R            if X >= Y:                D += [Y]                del R[1:3]                add_pt = False            else:                add_pt = True            # 9: Repeat until done        if len(D) == 0:            D = 0        return D    if __name__ == '__main__':    batt_attr_file = '../data/battery_attributes.json'    batt_attr_file = os.path.join(os.getcwd(), batt_attr_file)    soc_temp_file = '../../../docs/Deg_SoC_Temp.xlsx'    soc_temp_file = os.path.join(os.getcwd(),soc_temp_file)    with open(batt_attr_file, 'r') as f:        batt_attr = json.load(f)    # Convert json to dataframe    batt_columns = np.array([k for k in batt_attr.keys()])    batt_values = np.array([v for v in batt_attr.values()])    batt_values = np.reshape(batt_values, (1, len(batt_values))).astype('float')    resource_str = pd.DataFrame(batt_values, columns=batt_columns)    soc_temp = pd.read_excel(soc_temp_file, sheet_name='raw data')    idx1 = 0    for d in range(29):        idx2 = idx1+288*(d+1) # One day later = 288 5-minute intervals                # Read in soc, temperature, and times        soc_array = np.array(soc_temp.loc[idx1:idx2,'soc_R00229'].values)        soc_array = np.reshape(soc_array, (1, len(soc_array)))                temp_array = np.array(soc_temp.loc[idx1:idx2,'temp_R00229'].values)        temp_array = np.reshape(temp_array, (1, len(temp_array)))                times_array = pd.to_datetime(soc_temp.loc[idx1:idx2, 'Time'].values)        t_start = times_array[-289]                # Compute the degradation cost        battery_deg = Degradation(soc_array, temp_array, times_array, t_start, resource_str)        deg_costs = battery_deg.compute_degradation_cost()        print(f"Degradation Cost on day {d+1} is ${deg_costs}")